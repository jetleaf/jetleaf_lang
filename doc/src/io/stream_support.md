# Stream Support Utilities

## Overview

The `StreamSupport` class provides low-level utility methods for creating and manipulating streams in the JetLeaf framework. It serves as a factory for creating different types of streams with various characteristics (sequential, parallel, typed, etc.).

## Core Features

- **Stream Creation**: Create streams from various sources (iterables, suppliers, etc.)
- **Type-Specific Streams**: Specialized streams for `int` and `double` types
- **Parallel Processing**: Support for parallel stream operations
- **Builder Pattern**: Fluent API for constructing complex streams
- **Utility Methods**: Common stream operations and transformations

## Basic Usage

### Creating Streams from Iterables

```dart
import 'package:jetleaf_lang/jetleaf_lang.dart';

void main() async {
  // Create a sequential stream from an iterable
  final sequential = StreamSupport.stream([1, 2, 3, 4, 5]);
  
  // Create a parallel stream
  final parallel = StreamSupport.stream([1, 2, 3, 4, 5], parallel: true);
  
  // Type-specific streams
  final intStream = StreamSupport.intStream([1, 2, 3]);
  final doubleStream = StreamSupport.doubleStream([1.1, 2.2, 3.3]);
  
  // Process streams
  final sum = await intStream.sum();
  print('Sum: $sum'); // 6
}
```

## API Reference

### Factory Methods

#### `stream(Iterable<T> source, {bool parallel = false})`
Creates a new sequential or parallel `GenericStream` from an `Iterable`.

**Parameters**:
- `source`: The iterable to create a stream from
- `parallel`: Whether the stream should be parallel (default: `false`)

**Example**:
```dart
final stream = StreamSupport.stream([1, 2, 3, 4, 5]);
final parallelStream = StreamSupport.stream([1, 2, 3], parallel: true);
```

#### `intStream(Iterable<int> source, {bool parallel = false})`
Creates a new sequential or parallel `IntStream` from an `Iterable<int>`.

**Example**:
```dart
final intStream = StreamSupport.intStream([1, 2, 3, 4, 5]);
final sum = await intStream.sum();
```

#### `doubleStream(Iterable<double> source, {bool parallel = false})`
Creates a new sequential or parallel `DoubleStream` from an `Iterable<double>`.

**Example**:
```dart
final doubleStream = StreamSupport.doubleStream([1.1, 2.2, 3.3]);
final average = await doubleStream.average();
```

### Stream Creation Helpers

#### `empty<T>()`
Creates an empty `GenericStream<T>`.

**Example**:
```dart
final empty = StreamSupport.empty<String>();
print(await empty.count()); // 0
```

#### `ofSingle(T value)`
Creates a stream containing a single element.

**Example**:
```dart
final single = StreamSupport.ofSingle('Hello');
print(await single.toList()); // ['Hello']
```

#### `generate(T Function() supplier)`
Creates an infinite stream where each element is generated by the provided supplier.

**Example**:
```dart
final random = StreamSupport.generate(() => Random().nextInt(100));
final firstTen = await random.limit(10).toList();
```

#### `iterate(T seed, T Function(T) f)`
Creates an infinite stream by iterative application of a function.

**Example**:
```dart
final powers = StreamSupport.iterate(1, (n) => n * 2)
    .limit(10); // 1, 2, 4, 8, 16, 32, 64, 128, 256, 512
```

### Stream Building

#### `builder<T>()`
Returns a builder for creating streams with a fluent API.

**Example**:
```dart
final stream = StreamSupport.builder<String>()
    .add('Hello')
    .add(' ')
    .add('World')
    .build();
```

## Advanced Usage

### Parallel Processing

```dart
void main() async {
  final numbers = List.generate(1000000, (i) => i);
  
  // Sequential processing
  final start1 = DateTime.now();
  final seqSum = await StreamSupport.stream(numbers).sum();
  print('Sequential: ${DateTime.now().difference(start1)}');
  
  // Parallel processing
  final start2 = DateTime.now();
  final parSum = await StreamSupport.stream(numbers, parallel: true).sum();
  print('Parallel: ${DateTime.now().difference(start2)}');
}
```

### Custom Stream Operations

```dart
extension StreamExtensions<T> on GenericStream<T> {
  /// Returns a stream containing only the non-null elements.
  GenericStream<T> whereNotNull() {
    return where((element) => element != null);
  }
  
  /// Groups elements into lists of the specified size.
  GenericStream<List<T>> chunk(int size) {
    final list = this.toList();
    return StreamSupport.stream(
      List.generate(
        (list.length / size).ceil(),
        (i) => list.sublist(i * size, (i + 1) * size > list.length ? list.length : (i + 1) * size),
      ),
    );
  }
}
```

## Performance Considerations

1. **Parallel Processing**: 
   - Use parallel streams for CPU-bound operations on large datasets
   - Be aware of the overhead of parallelization for small datasets
   - Consider the number of available processors

2. **Memory Usage**:
   - Large intermediate operations may consume significant memory
   - Use `lazy` evaluation when possible

3. **Stream Characteristics**:
   - `SIZED`: The stream has a known size
   - `SORTED`: The stream is sorted
   - `DISTINCT`: The stream contains no duplicate elements
   - `IMMUTABLE`: The stream source cannot be modified
   - `NONNULL`: The stream contains no null elements
   - `ORDERED`: The stream has an encounter order

## Error Handling

```dart
Future<void> processStream(GenericStream<int> stream) async {
  try {
    final result = await stream
        .map((n) => n * 2)
        .filter((n) => n > 10)
        .toList();
    print('Result: $result');
  } on StateError catch (e) {
    print('Stream processing error: $e');
  } catch (e, stackTrace) {
    print('Unexpected error: $e\n$stackTrace');
  }
}
```

## Testing Streams

```dart
void main() {
  test('stream operations', () async {
    final stream = StreamSupport.stream([1, 2, 3, 4, 5]);
    
    // Test mapping
    final mapped = await stream.map((n) => n * 2).toList();
    expect(mapped, [2, 4, 6, 8, 10]);
    
    // Test filtering
    final filtered = await stream.filter((n) => n.isEven).toList();
    expect(filtered, [2, 4]);
    
    // Test reduction
    final sum = await stream.reduce(0, (a, b) => a + b);
    expect(sum, 15);
  });
}
```

## Best Practices

1. **Use Type-Specific Streams**: When working with primitive types (`int`, `double`), use the appropriate type-specific stream for better performance.

2. **Close Resources**: Always close resources when done:
   ```dart
   final resource = SomeResource();
   try {
     final stream = StreamSupport.stream(generateData(resource));
     // Process stream
   } finally {
     await resource.close();
   }
   ```

3. **Avoid Stateful Operations**: Keep stream operations stateless and pure when possible.

4. **Use Parallelism Judiciously**: Not all operations benefit from parallel processing. Measure performance to determine if parallelization is beneficial.

## See Also

- [Stream Builder](stream_builder.md) - For building complex streams
- [I/O Operations](../io/README.md) - For working with I/O streams
- [Concurrency](../concurrency/README.md) - For advanced parallel processing
